{"version":3,"file":"shapes.umd.js","sources":["../lib/utils/vertex-utils.js","../lib/utils/polygon-utils.js","../lib/utils/line-to-polygon.js","../lib/polygon/core/create-polygon-vertices.js","../lib/polygon/core/transform-polygon-vertices.js","../lib/rendering/build-path.js","../lib/boolean-operations/index.js","../lib/polygon/base-polygon.js","../lib/utils/rounded-polygon-vertices.js","../lib/utils/spline-polygon-vertices.js","../lib/polygon/index.js"],"sourcesContent":["/**\n * Get the distance beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Distance beween Point 1 & Point 2.\n */\nfunction distBetweenPoints(p1, p2) {\n  var a = p1[0] - p2[0];\n  var b = p1[1] - p2[1];\n\n  return Math.sqrt(a * a + b * b);\n}\n\n/**\n * Get the angle beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Angle beween Point 1 & Point 2.\n */\nfunction angleBetweenPoints(p1, p2) {\n  return (Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180) / Math.PI;\n}\n\nfunction filterClosePoints(arr, d) {\n  const result = [arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    const currentPoint = arr[i];\n\n    if (!result.some((p) => distBetweenPoints(p, currentPoint) <= d)) {\n      result.push(currentPoint);\n    }\n  }\n\n  return result;\n}\n\nfunction lerp(position, target, amt) {\n  return [\n    (position[0] += (target[0] - position[0]) * amt),\n    (position[1] += (target[1] - position[1]) * amt),\n  ];\n}\n\nexport { distBetweenPoints, angleBetweenPoints, filterClosePoints, lerp };\n","import { polygonBounds, polygonCentroid, polygonArea } from 'geometric';\nimport offsetPolygonFn from 'offset-polygon';\n\n/**\n * Polygons can be made up of lots of nested polygon arrays (often after boolean operations).\n * This function is useful for performing operations on every nested polygon within a polygon.\n *\n * @param {array} polygon - Base polygon to extract nested polygons from.\n * @param {function} callback - Runs for each unique polygon. Useful for modifying in-place.\n *\n * @returns {array} A flat array of polygons [[p1], [[p1]] ...].\n */\nfunction extractNestedPolygons(polygon, callback) {\n  if (polygon.length === 0) return [];\n\n  const polygons = [];\n\n  // Is this just a standalone polygon? [[x, y], [x, y]...]\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    if (!!callback) {\n      callback(polygon[0]);\n    } else {\n      polygons.push(polygon[0]);\n    }\n  } else {\n    // This is a nested polygon!\n    for (let i = 0; i < polygon.length; i++) {\n      const current = polygon[i];\n\n      // There is only one nested polygon in this array\n      if (current.length === 1) {\n        if (!!callback) {\n          callback(current[0]);\n        } else {\n          polygons.push(current[0]);\n        }\n      } else {\n        // There is more than one nested polygon in this array\n        for (let j = 0; j < current.length; j++) {\n          if (!!callback) {\n            callback(current[j]);\n          } else {\n            polygons.push(current[j]);\n          }\n        }\n      }\n    }\n  }\n\n  return polygons;\n}\n\n/**\n * Create deep clone of a polygon.\n *\n * @param {array} polygon - Polygon to clone.\n *\n * @returns {array} Deep clone of the polygon input.\n */\nfunction clonePolygon(polygon) {\n  return JSON.parse(JSON.stringify(polygon));\n}\n\n/**\n * Get a polygon's bounds.\n *\n * @param {array} polygon\n *\n * @returns {object} Polygon's bounding rect ({ x, y, width, height }).\n */\nfunction getPolygonBounds(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  const [topLeft, bottomRight] = polygonBounds(vertices);\n\n  return {\n    x: topLeft[0],\n    y: topLeft[1],\n    width: bottomRight[0] - topLeft[0],\n    height: bottomRight[1] - topLeft[1],\n  };\n}\n\nfunction getPolygonArea(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonArea(vertices);\n}\n\nfunction getPolygonCentroid(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonCentroid(vertices);\n}\n\nfunction offsetPolygon(polygon, size) {\n  let formattedPolygon = polygon.map((v) => ({ x: v[0], y: v[1] }));\n  let hasPerformedFixup = false;\n\n  if (\n    JSON.stringify(formattedPolygon[0]) ===\n    JSON.stringify(formattedPolygon[formattedPolygon.length - 1])\n  ) {\n    formattedPolygon = formattedPolygon.slice(0, formattedPolygon.length - 1);\n\n    hasPerformedFixup = true;\n  }\n\n  const offset = offsetPolygonFn(formattedPolygon, size, 0);\n\n  if (hasPerformedFixup) {\n    offset.push(offset[0]);\n  }\n\n  return offset.map((v) => [v.x, v.y]);\n}\n\nexport {\n  extractNestedPolygons,\n  clonePolygon,\n  getPolygonBounds,\n  offsetPolygon,\n  getPolygonCentroid,\n  getPolygonArea,\n};\n","var line2Polygon = (function () {\n  function getOffsets(a, b, thickness) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      len = Math.sqrt(dx * dx + dy * dy),\n      scale = thickness / (2 * len);\n    return {\n      x: -scale * dy,\n      y: scale * dx,\n    };\n  }\n\n  function getIntersection(a1, b1, a2, b2) {\n    // directional constants\n    var k1 = (b1.y - a1.y) / (b1.x - a1.x),\n      k2 = (b2.y - a2.y) / (b2.x - a2.x);\n\n    // if the directional constants are equal, the lines are parallel\n    if (k1 === k2 || Math.abs(k1 - k2) < 0.00001) {\n      return;\n    }\n\n    // y offset constants for both lines\n    var m1 = a1.y - k1 * a1.x;\n    var m2 = a2.y - k2 * a2.x;\n\n    // compute x\n    var x = (m1 - m2) / (k2 - k1);\n\n    // use y = k * x + m to get y coordinate\n    var y = k1 * x + m1;\n\n    return { x: x, y: y };\n  }\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function me(points, thickness) {\n    //Convert points into json notation\n    var arr = [];\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      arr.push({\n        x: pt[0],\n        y: pt[1],\n      });\n    }\n    points = arr;\n\n    //Convert thickness into an array as needed\n    if (!isArray(thickness)) {\n      var t = thickness;\n      thickness = [];\n      for (var i = 0; i < points.length; i++) {\n        thickness.push(t);\n      }\n    }\n\n    var off,\n      off2,\n      poly = [],\n      isFirst,\n      isLast,\n      prevA,\n      prevB,\n      interA,\n      interB,\n      p0a,\n      p1a,\n      p0b,\n      p1b;\n\n    for (var i = 0, il = points.length - 1; i < il; i++) {\n      isFirst = !i;\n      isLast = i === points.length - 2;\n\n      off = getOffsets(points[i], points[i + 1], thickness[i]);\n      off2 = getOffsets(points[i], points[i + 1], thickness[i + 1]);\n\n      p0a = { x: points[i].x + off.x, y: points[i].y + off.y };\n      p1a = { x: points[i + 1].x + off2.x, y: points[i + 1].y + off2.y };\n\n      p0b = { x: points[i].x - off.x, y: points[i].y - off.y };\n      p1b = { x: points[i + 1].x - off2.x, y: points[i + 1].y - off2.y };\n\n      if (!isFirst) {\n        interA = getIntersection(prevA[0], prevA[1], p0a, p1a);\n        if (interA) {\n          poly.unshift(interA);\n        }\n        interB = getIntersection(prevB[0], prevB[1], p0b, p1b);\n        if (interB) {\n          poly.push(interB);\n        }\n      }\n\n      if (isFirst) {\n        poly.unshift(p0a);\n        poly.push(p0b);\n      }\n\n      if (isLast) {\n        poly.unshift(p1a);\n        poly.push(p1b);\n      }\n\n      if (!isLast) {\n        prevA = [p0a, p1a];\n        prevB = [p0b, p1b];\n      }\n    }\n\n    for (var i = 0; i < poly.length; i++) {\n      var pt = poly[i];\n      poly[i] = [pt.x, pt.y];\n    }\n    poly.push(poly[0]);\n\n    return poly.filter((x) => !isNaN(x[0]) && !isNaN(x[1]));\n  }\n\n  return me;\n})();\n\nfunction lineToPolygon(line, width) {\n  return line2Polygon(line, width);\n}\n\nexport { lineToPolygon };\n","import { lineToPolygon } from '../../utils';\nimport quadratic from 'adaptive-quadratic-curve';\n\nfunction createRectPolygonVertices(width, height) {\n  const vertices = [\n    [0, 0],\n    [width, 0],\n    [width, height],\n    [0, height],\n    [0, 0],\n  ];\n\n  return [vertices];\n}\n\nfunction createEllipsePolygonVertices(width, height, numPoints = 64) {\n  const vertices = [];\n  const angleStep = (Math.PI * 2) / numPoints;\n\n  for (let i = 1; i <= numPoints; i++) {\n    vertices.push([\n      (Math.cos(i * angleStep) * width) / 2 + width / 2,\n      (Math.sin(i * angleStep) * height) / 2 + height / 2,\n    ]);\n  }\n\n  vertices.push(vertices[0]);\n\n  return [vertices];\n}\n\nfunction createLinePolygonVertices(points, width = 1) {\n  return [lineToPolygon(points, width)];\n}\n\nfunction createQuadraticCurvePolygonVertices(\n  start,\n  c1,\n  end,\n  width = 1,\n  scale = 8\n) {\n  return [lineToPolygon(quadratic(start, c1, end, scale), width)];\n}\n\nexport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n};\n","import {\n  polygonTranslate,\n  polygonRotate,\n  polygonScaleX,\n  polygonScaleY,\n  polygonArea,\n} from 'geometric';\n\nimport polygonClipping from 'polygon-clipping';\nimport simplepolygon from 'simplepolygon';\nimport simplify from 'simplify-path';\n\nimport {\n  distBetweenPoints,\n  angleBetweenPoints,\n  getPolygonBounds,\n  extractNestedPolygons,\n  offsetPolygon,\n  clonePolygon,\n  roundedPolygonVertices,\n  splinePolygonVertices,\n  filterClosePoints,\n  lerp,\n  getPolygonCentroid,\n} from '../../utils';\n\nimport { distanceToPolygon } from 'distance-to-polygon';\n\nfunction translatePolygonTopLeft(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  if (targetX === null) {\n    targetX = bounds.x;\n  }\n\n  if (targetY === null) {\n    targetY = bounds.y;\n  }\n\n  const currentTopLeft = [bounds.x, bounds.y];\n  const targetTopLeft = [targetX, targetY];\n\n  const dist = distBetweenPoints(currentTopLeft, targetTopLeft);\n  const angle = angleBetweenPoints(currentTopLeft, targetTopLeft);\n\n  extractNestedPolygons(polygon, (p) => {\n    const t = polygonTranslate(p, angle, dist);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < t.length; i++) p[i] = t[i];\n  });\n\n  return polygon;\n}\n\nfunction translatePolygonCenter(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  const targetTopLeft = [\n    targetX === null ? bounds.x : targetX - bounds.width / 2,\n    targetY === null ? bounds.y : targetY - bounds.height / 2,\n  ];\n\n  return translatePolygonTopLeft(polygon, targetTopLeft[0], targetTopLeft[1]);\n}\n\nfunction rotatePolygon(polygon, angle) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const r = polygonRotate(p, angle, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < r.length; i++) p[i] = r[i];\n  });\n\n  return polygon;\n}\n\nfunction scalePolygon(polygon, amountX = 1, amountY = 1) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const sX = polygonScaleX(p, amountX, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    const sY = polygonScaleY(sX, amountY, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < sY.length; i++) p[i] = sY[i];\n  });\n\n  return polygon;\n}\n\nfunction strokePolygon(polygon, size = 1) {\n  let target = null;\n\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    target = polygon[0];\n  } else if (polygon.length === 1 && polygon[0].length === 1) {\n    target = polygon[0][0];\n  }\n\n  if (target) {\n    const offset = offsetPolygon(target, -size);\n\n    // trim off self intersections!\n    let result = simplepolygon({\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          filterClosePoints(\n            offset.filter(\n              (v) => typeof v[0] === 'number' && typeof v[0] === 'number'\n            ),\n            0\n          ),\n        ],\n      },\n    })\n      .features.map((f) => f.geometry.coordinates[0])\n      .sort((a, b) => polygonArea(b) - polygonArea(a))[0]\n      .filter((p) => distanceToPolygon(p, target) >= size - 1);\n\n    return polygonClipping.difference(polygon, [result]);\n  } else {\n    console.warn('Only simple polygons can have a stroke applied.');\n  }\n\n  return polygon;\n}\n\nfunction radiusPolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = roundedPolygonVertices(clonePolygon(p), radius);\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction splinePolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = splinePolygonVertices(\n      clonePolygon(p),\n      radius,\n      true\n    );\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction simplifyPolygon(polygon, tolerance) {\n  extractNestedPolygons(polygon, (p) => {\n    const simplified = simplify(clonePolygon(p), tolerance);\n    const centroid = getPolygonCentroid([p]);\n\n    p.splice(simplified.length, p.length - simplified.length);\n\n    for (let i = 0; i < simplified.length; i++) {\n      p[i] = lerp(simplified[i], centroid, 0);\n\n      // p[i][0] += random(-4, 4);\n      // p[i][1] += random(-4, 4);\n    }\n\n    p[p.length - 1] = p[0];\n  });\n\n  return polygon;\n}\n\nexport {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n};\n","import { extractNestedPolygons } from '../utils';\n\nfunction buildPath(polygon) {\n  const verticeSets = extractNestedPolygons(polygon.vertices);\n\n  let basePathData = '';\n\n  for (const polygon of verticeSets) {\n    let pathData = '';\n\n    pathData += `M ${polygon[0][0].toFixed(2)} ${polygon[0][1].toFixed(2)}`;\n\n    for (let i = 1; i < polygon.length; i++) {\n      pathData += `L ${polygon[i][0].toFixed(2)} ${polygon[i][1].toFixed(2)}`;\n    }\n\n    pathData += `Z`;\n\n    basePathData += pathData;\n  }\n\n  return basePathData;\n}\n\nexport { buildPath };\n","import polygonClipping from 'polygon-clipping';\n\nimport { polygon } from '../polygon';\n\nfunction union(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.union(...vertices));\n}\n\nfunction difference(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.difference(...vertices));\n}\n\nfunction xor(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.xor(...vertices));\n}\n\nfunction intersection(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.intersection(...vertices));\n}\n\nexport { union, difference, xor, intersection };\n","import {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n} from './core';\n\nimport { buildPath } from '../rendering';\n\nimport { clonePolygon, getPolygonBounds, getPolygonArea } from '../utils';\nimport { intersection } from '../boolean-operations';\n\nclass BasePolygon {\n  constructor(vertices) {\n    this.vertices = vertices;\n  }\n\n  x(x) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  y(y) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  cx(x) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  cy(y) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  rotate(degrees = 0) {\n    this.vertices = rotatePolygon(clonePolygon(this.vertices), degrees);\n\n    return this;\n  }\n\n  scale(amountX = 1, amountY = null) {\n    if (amountY === null) {\n      amountY = amountX;\n    }\n\n    this.vertices = scalePolygon(clonePolygon(this.vertices), amountX, amountY);\n\n    return this;\n  }\n\n  offset(size) {\n    if (size >= 1) {\n      this.vertices = strokePolygon(clonePolygon(this.vertices), size);\n    }\n\n    return this;\n  }\n\n  radius(amount) {\n    if (amount >= 0) {\n      this.vertices = radiusPolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  spline(amount) {\n    if (amount > 0) {\n      this.vertices = splinePolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  simplify(tolerance = 16) {\n    this.vertices = simplifyPolygon(clonePolygon(this.vertices), tolerance);\n\n    return this;\n  }\n\n  checkIntersection(targets, amount = 1) {\n    // Wrap in a try/catch to account for occasional polygonClipping weirdness\n    try {\n      if (\n        targets.some(\n          (s) => !!intersection(s.clone(), this.clone()).vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 * amount))\n              .vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 / amount))\n              .vertices[0]\n        )\n      ) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch {\n      return true;\n    }\n  }\n\n  getBounds() {\n    return getPolygonBounds(this.vertices);\n  }\n\n  getArea() {\n    return getPolygonArea(this.vertices);\n  }\n\n  clone() {\n    return new BasePolygon(clonePolygon(this.vertices));\n  }\n\n  buildPath() {\n    return buildPath(this.clone());\n  }\n}\n\nexport { BasePolygon };\n","import quadratic from 'adaptive-quadratic-curve';\n\nfunction roundedPolygonVertices(points, radius) {\n  points = points.map((p) => ({ x: p[0], y: p[1] }));\n\n  if (radius === 0) {\n    radius = 0.0000001;\n  }\n\n  if (\n    points[0].x === points[points.length - 1].x &&\n    points[0].y === points[points.length - 1].y\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  const result = [];\n\n  const distance = (p1, p2) =>\n    Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n\n  const lerp = (a, b, x) => a + (b - a) * x;\n\n  const lerp2D = (p1, p2, t) => ({\n    x: lerp(p1.x, p2.x, t),\n    y: lerp(p1.y, p2.y, t),\n  });\n\n  const numPoints = points.length;\n\n  let corners = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    let lastPoint = points[i];\n    let thisPoint = points[(i + 1) % numPoints];\n    let nextPoint = points[(i + 2) % numPoints];\n\n    let lastEdgeLength = distance(lastPoint, thisPoint);\n    let lastOffsetDistance = Math.min(lastEdgeLength / 2, radius);\n    let start = lerp2D(\n      thisPoint,\n      lastPoint,\n      lastOffsetDistance / lastEdgeLength\n    );\n\n    let nextEdgeLength = distance(nextPoint, thisPoint);\n    let nextOffsetDistance = Math.min(nextEdgeLength / 2, radius);\n    let end = lerp2D(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n\n    corners.push([start, thisPoint, end]);\n  }\n\n  for (let [start, ctrl, end] of corners) {\n    result.push(\n      ...quadratic([start.x, start.y], [ctrl.x, ctrl.y], [end.x, end.y], 8)\n    );\n  }\n\n  return result;\n}\n\nexport { roundedPolygonVertices };\n","import { distBetweenPoints, filterClosePoints } from './index';\n\nimport bezier from 'adaptive-bezier-curve';\n\nfunction formatPoints(points, close) {\n  points = [...points];\n\n  if (!Array.isArray(points[0])) {\n    points = points.map(({ x, y }) => [x, y]);\n  }\n\n  if (close) {\n    const lastPoint = points[points.length - 1];\n    const secondToLastPoint = points[points.length - 2];\n\n    const firstPoint = points[0];\n    const secondPoint = points[1];\n\n    points.unshift(lastPoint);\n    points.unshift(secondToLastPoint);\n\n    points.push(firstPoint);\n    points.push(secondPoint);\n  }\n\n  return points.flat();\n}\n\nfunction splinePolygonVertices(points = [], tension = 1, close = true) {\n  if (\n    points[0][0] === points[points.length - 1][0] &&\n    points[0][1] === points[points.length - 1][1]\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  points = formatPoints(points, close);\n\n  const result = [];\n\n  const size = points.length;\n  const last = size - 4;\n\n  const startPointX = close ? points[2] : points[0];\n  const startPointY = close ? points[3] : points[1];\n\n  result.push([startPointX, startPointY]);\n\n  const startIteration = close ? 2 : 0;\n  const maxIteration = close ? size - 4 : size - 2;\n  const inc = 2;\n\n  const baseTension = tension;\n\n  for (let i = startIteration; i < maxIteration; i += inc) {\n    const x0 = i ? points[i - 2] : points[0];\n    const y0 = i ? points[i - 1] : points[1];\n\n    const x1 = points[i + 0];\n    const y1 = points[i + 1];\n\n    const x2 = points[i + 2];\n    const y2 = points[i + 3];\n\n    if (distBetweenPoints([x1, y1], [x2, y2]) < 8) {\n      tension = 0.0001;\n    } else {\n      tension = baseTension;\n    }\n\n    const x3 = i !== last ? points[i + 4] : x2;\n    const y3 = i !== last ? points[i + 5] : y2;\n\n    const cp1x = x1 + ((x2 - x0) / 6) * tension;\n    const cp1y = y1 + ((y2 - y0) / 6) * tension;\n\n    const cp2x = x2 - ((x3 - x1) / 6) * tension;\n    const cp2y = y2 - ((y3 - y1) / 6) * tension;\n\n    result.push(...bezier([x1, y1], [cp1x, cp1y], [cp2x, cp2y], [x2, y2], 8));\n  }\n\n  return filterClosePoints(result, 0);\n}\n\nexport { splinePolygonVertices };\n","import { BasePolygon } from './base-polygon';\n\nimport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n} from './core';\n\nfunction rect(width, height) {\n  const vertices = createRectPolygonVertices(width, height);\n\n  return new BasePolygon(vertices);\n}\n\nfunction ellipse(width, height, numPoints) {\n  const vertices = createEllipsePolygonVertices(width, height, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction circle(radius, numPoints) {\n  const vertices = createEllipsePolygonVertices(radius, radius, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction polygon(vertices) {\n  return new BasePolygon(vertices);\n}\n\nfunction line(points, width) {\n  const vertices = createLinePolygonVertices(points, width);\n\n  return new BasePolygon(vertices);\n}\n\nfunction quadtratic(start, c1, end, width, scale) {\n  const vertices = createQuadraticCurvePolygonVertices(\n    start,\n    c1,\n    end,\n    width,\n    scale\n  );\n\n  return new BasePolygon(vertices);\n}\n\nexport { rect, ellipse, circle, polygon, line, quadtratic };\n"],"names":["distBetweenPoints","p1","p2","a","b","Math","sqrt","filterClosePoints","arr","d","result","i","currentPoint","some","p","push","length","extractNestedPolygons","polygon","callback","polygons","isNaN","current","j","clonePolygon","JSON","parse","stringify","getPolygonBounds","vertices","flat","polygonBounds","topLeft","bottomRight","x","y","width","height","line2Polygon","getOffsets","thickness","dx","dy","scale","getIntersection","a1","b1","a2","b2","k1","k2","abs","m1","points","pt","Object","prototype","toString","call","t","off","off2","isFirst","isLast","prevA","prevB","interA","interB","p0a","p1a","p0b","p1b","poly","il","unshift","filter","lineToPolygon","line","createEllipsePolygonVertices","numPoints","angleStep","PI","cos","sin","translatePolygonTopLeft","targetX","targetY","bounds","currentTopLeft","targetTopLeft","dist","angle","atan2","polygonTranslate","translatePolygonCenter","buildPath","basePathData","pathData","toFixed","intersection","map","polygonClipping","BasePolygon","this","cx","cy","rotate","degrees","r","polygonRotate","rotatePolygon","amountX","amountY","sX","polygonScaleX","sY","polygonScaleY","scalePolygon","offset","size","target","formattedPolygon","v","hasPerformedFixup","slice","offsetPolygonFn","offsetPolygon","simplepolygon","type","geometry","coordinates","features","f","sort","polygonArea","distanceToPolygon","difference","console","warn","strokePolygon","radius","amount","polygonWithRadius","distance","lerp","lerp2D","corners","lastPoint","thisPoint","nextPoint","lastEdgeLength","start","min","nextEdgeLength","end","ctrl","quadratic","roundedPolygonVertices","radiusPolygon","spline","tension","close","Array","isArray","secondToLastPoint","firstPoint","secondPoint","formatPoints","last","maxIteration","baseTension","x0","y0","x1","y1","x2","y2","bezier","splinePolygonVertices","splinePolygon","simplify","tolerance","position","simplified","centroid","polygonCentroid","getPolygonCentroid","splice","simplifyPolygon","checkIntersection","targets","s","clone","_this","getBounds","getArea","getPolygonArea","createLinePolygonVertices","c1","createQuadraticCurvePolygonVertices","createRectPolygonVertices","union","xor"],"mappings":"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"}