{"version":3,"file":"shapes.modern.js","sources":["../lib/utils/vertex-utils.js","../lib/utils/polygon-utils.js","../lib/utils/line-to-polygon.js","../lib/polygon/core/create-polygon-vertices.js","../lib/polygon/core/transform-polygon-vertices.js","../lib/rendering/build-path.js","../lib/boolean-operations/index.js","../lib/polygon/base-polygon.js","../lib/utils/rounded-polygon-vertices.js","../lib/utils/spline-polygon-vertices.js","../lib/polygon/index.js"],"sourcesContent":["/**\n * Get the distance beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Distance beween Point 1 & Point 2.\n */\nfunction distBetweenPoints(p1, p2) {\n  var a = p1[0] - p2[0];\n  var b = p1[1] - p2[1];\n\n  return Math.sqrt(a * a + b * b);\n}\n\n/**\n * Get the angle beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Angle beween Point 1 & Point 2.\n */\nfunction angleBetweenPoints(p1, p2) {\n  return (Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180) / Math.PI;\n}\n\nfunction filterClosePoints(arr, d) {\n  const result = [arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    const currentPoint = arr[i];\n\n    if (!result.some((p) => distBetweenPoints(p, currentPoint) <= d)) {\n      result.push(currentPoint);\n    }\n  }\n\n  return result;\n}\n\nfunction lerp(position, target, amt) {\n  return [\n    (position[0] += (target[0] - position[0]) * amt),\n    (position[1] += (target[1] - position[1]) * amt),\n  ];\n}\n\nexport { distBetweenPoints, angleBetweenPoints, filterClosePoints, lerp };\n","import { polygonBounds, polygonCentroid, polygonArea } from 'geometric';\nimport offsetPolygonFn from 'offset-polygon';\n\n/**\n * Polygons can be made up of lots of nested polygon arrays (often after boolean operations).\n * This function is useful for performing operations on every nested polygon within a polygon.\n *\n * @param {array} polygon - Base polygon to extract nested polygons from.\n * @param {function} callback - Runs for each unique polygon. Useful for modifying in-place.\n *\n * @returns {array} A flat array of polygons [[p1], [[p1]] ...].\n */\nfunction extractNestedPolygons(polygon, callback) {\n  if (polygon.length === 0) return [];\n\n  const polygons = [];\n\n  // Is this just a standalone polygon? [[x, y], [x, y]...]\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    if (!!callback) {\n      callback(polygon[0]);\n    } else {\n      polygons.push(polygon[0]);\n    }\n  } else {\n    // This is a nested polygon!\n    for (let i = 0; i < polygon.length; i++) {\n      const current = polygon[i];\n\n      // There is only one nested polygon in this array\n      if (current.length === 1) {\n        if (!!callback) {\n          callback(current[0]);\n        } else {\n          polygons.push(current[0]);\n        }\n      } else {\n        // There is more than one nested polygon in this array\n        for (let j = 0; j < current.length; j++) {\n          if (!!callback) {\n            callback(current[j]);\n          } else {\n            polygons.push(current[j]);\n          }\n        }\n      }\n    }\n  }\n\n  return polygons;\n}\n\n/**\n * Create deep clone of a polygon.\n *\n * @param {array} polygon - Polygon to clone.\n *\n * @returns {array} Deep clone of the polygon input.\n */\nfunction clonePolygon(polygon) {\n  return JSON.parse(JSON.stringify(polygon));\n}\n\n/**\n * Get a polygon's bounds.\n *\n * @param {array} polygon\n *\n * @returns {object} Polygon's bounding rect ({ x, y, width, height }).\n */\nfunction getPolygonBounds(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  const [topLeft, bottomRight] = polygonBounds(vertices);\n\n  return {\n    x: topLeft[0],\n    y: topLeft[1],\n    width: bottomRight[0] - topLeft[0],\n    height: bottomRight[1] - topLeft[1],\n  };\n}\n\nfunction getPolygonArea(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonArea(vertices);\n}\n\nfunction getPolygonCentroid(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonCentroid(vertices);\n}\n\nfunction offsetPolygon(polygon, size) {\n  let formattedPolygon = polygon.map((v) => ({ x: v[0], y: v[1] }));\n  let hasPerformedFixup = false;\n\n  if (\n    JSON.stringify(formattedPolygon[0]) ===\n    JSON.stringify(formattedPolygon[formattedPolygon.length - 1])\n  ) {\n    formattedPolygon = formattedPolygon.slice(0, formattedPolygon.length - 1);\n\n    hasPerformedFixup = true;\n  }\n\n  const offset = offsetPolygonFn(formattedPolygon, size, 0);\n\n  if (hasPerformedFixup) {\n    offset.push(offset[0]);\n  }\n\n  return offset.map((v) => [v.x, v.y]);\n}\n\nexport {\n  extractNestedPolygons,\n  clonePolygon,\n  getPolygonBounds,\n  offsetPolygon,\n  getPolygonCentroid,\n  getPolygonArea,\n};\n","var line2Polygon = (function () {\n  function getOffsets(a, b, thickness) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      len = Math.sqrt(dx * dx + dy * dy),\n      scale = thickness / (2 * len);\n    return {\n      x: -scale * dy,\n      y: scale * dx,\n    };\n  }\n\n  function getIntersection(a1, b1, a2, b2) {\n    // directional constants\n    var k1 = (b1.y - a1.y) / (b1.x - a1.x),\n      k2 = (b2.y - a2.y) / (b2.x - a2.x);\n\n    // if the directional constants are equal, the lines are parallel\n    if (k1 === k2 || Math.abs(k1 - k2) < 0.00001) {\n      return;\n    }\n\n    // y offset constants for both lines\n    var m1 = a1.y - k1 * a1.x;\n    var m2 = a2.y - k2 * a2.x;\n\n    // compute x\n    var x = (m1 - m2) / (k2 - k1);\n\n    // use y = k * x + m to get y coordinate\n    var y = k1 * x + m1;\n\n    return { x: x, y: y };\n  }\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function me(points, thickness) {\n    //Convert points into json notation\n    var arr = [];\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      arr.push({\n        x: pt[0],\n        y: pt[1],\n      });\n    }\n    points = arr;\n\n    //Convert thickness into an array as needed\n    if (!isArray(thickness)) {\n      var t = thickness;\n      thickness = [];\n      for (var i = 0; i < points.length; i++) {\n        thickness.push(t);\n      }\n    }\n\n    var off,\n      off2,\n      poly = [],\n      isFirst,\n      isLast,\n      prevA,\n      prevB,\n      interA,\n      interB,\n      p0a,\n      p1a,\n      p0b,\n      p1b;\n\n    for (var i = 0, il = points.length - 1; i < il; i++) {\n      isFirst = !i;\n      isLast = i === points.length - 2;\n\n      off = getOffsets(points[i], points[i + 1], thickness[i]);\n      off2 = getOffsets(points[i], points[i + 1], thickness[i + 1]);\n\n      p0a = { x: points[i].x + off.x, y: points[i].y + off.y };\n      p1a = { x: points[i + 1].x + off2.x, y: points[i + 1].y + off2.y };\n\n      p0b = { x: points[i].x - off.x, y: points[i].y - off.y };\n      p1b = { x: points[i + 1].x - off2.x, y: points[i + 1].y - off2.y };\n\n      if (!isFirst) {\n        interA = getIntersection(prevA[0], prevA[1], p0a, p1a);\n        if (interA) {\n          poly.unshift(interA);\n        }\n        interB = getIntersection(prevB[0], prevB[1], p0b, p1b);\n        if (interB) {\n          poly.push(interB);\n        }\n      }\n\n      if (isFirst) {\n        poly.unshift(p0a);\n        poly.push(p0b);\n      }\n\n      if (isLast) {\n        poly.unshift(p1a);\n        poly.push(p1b);\n      }\n\n      if (!isLast) {\n        prevA = [p0a, p1a];\n        prevB = [p0b, p1b];\n      }\n    }\n\n    for (var i = 0; i < poly.length; i++) {\n      var pt = poly[i];\n      poly[i] = [pt.x, pt.y];\n    }\n    poly.push(poly[0]);\n\n    return poly.filter((x) => !isNaN(x[0]) && !isNaN(x[1]));\n  }\n\n  return me;\n})();\n\nfunction lineToPolygon(line, width) {\n  return line2Polygon(line, width);\n}\n\nexport { lineToPolygon };\n","import { lineToPolygon } from '../../utils';\nimport quadratic from 'adaptive-quadratic-curve';\n\nfunction createRectPolygonVertices(width, height) {\n  const vertices = [\n    [0, 0],\n    [width, 0],\n    [width, height],\n    [0, height],\n    [0, 0],\n  ];\n\n  return [vertices];\n}\n\nfunction createEllipsePolygonVertices(width, height, numPoints = 64) {\n  const vertices = [];\n  const angleStep = (Math.PI * 2) / numPoints;\n\n  for (let i = 1; i <= numPoints; i++) {\n    vertices.push([\n      (Math.cos(i * angleStep) * width) / 2 + width / 2,\n      (Math.sin(i * angleStep) * height) / 2 + height / 2,\n    ]);\n  }\n\n  vertices.push(vertices[0]);\n\n  return [vertices];\n}\n\nfunction createLinePolygonVertices(points, width = 1) {\n  return [lineToPolygon(points, width)];\n}\n\nfunction createQuadraticCurvePolygonVertices(\n  start,\n  c1,\n  end,\n  width = 1,\n  scale = 8\n) {\n  return [lineToPolygon(quadratic(start, c1, end, scale), width)];\n}\n\nexport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n};\n","import {\n  polygonTranslate,\n  polygonRotate,\n  polygonScaleX,\n  polygonScaleY,\n  polygonArea,\n} from 'geometric';\n\nimport polygonClipping from 'polygon-clipping';\nimport simplepolygon from 'simplepolygon';\nimport simplify from 'simplify-path';\n\nimport {\n  distBetweenPoints,\n  angleBetweenPoints,\n  getPolygonBounds,\n  extractNestedPolygons,\n  offsetPolygon,\n  clonePolygon,\n  roundedPolygonVertices,\n  splinePolygonVertices,\n  filterClosePoints,\n  lerp,\n  getPolygonCentroid,\n} from '../../utils';\n\nimport { distanceToPolygon } from 'distance-to-polygon';\n\nfunction translatePolygonTopLeft(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  if (targetX === null) {\n    targetX = bounds.x;\n  }\n\n  if (targetY === null) {\n    targetY = bounds.y;\n  }\n\n  const currentTopLeft = [bounds.x, bounds.y];\n  const targetTopLeft = [targetX, targetY];\n\n  const dist = distBetweenPoints(currentTopLeft, targetTopLeft);\n  const angle = angleBetweenPoints(currentTopLeft, targetTopLeft);\n\n  extractNestedPolygons(polygon, (p) => {\n    const t = polygonTranslate(p, angle, dist);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < t.length; i++) p[i] = t[i];\n  });\n\n  return polygon;\n}\n\nfunction translatePolygonCenter(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  const targetTopLeft = [\n    targetX === null ? bounds.x : targetX - bounds.width / 2,\n    targetY === null ? bounds.y : targetY - bounds.height / 2,\n  ];\n\n  return translatePolygonTopLeft(polygon, targetTopLeft[0], targetTopLeft[1]);\n}\n\nfunction rotatePolygon(polygon, angle) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const r = polygonRotate(p, angle, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < r.length; i++) p[i] = r[i];\n  });\n\n  return polygon;\n}\n\nfunction scalePolygon(polygon, amountX = 1, amountY = 1) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const sX = polygonScaleX(p, amountX, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    const sY = polygonScaleY(sX, amountY, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < sY.length; i++) p[i] = sY[i];\n  });\n\n  return polygon;\n}\n\nfunction strokePolygon(polygon, size = 1) {\n  let target = null;\n\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    target = polygon[0];\n  } else if (polygon.length === 1 && polygon[0].length === 1) {\n    target = polygon[0][0];\n  }\n\n  if (target) {\n    const offset = offsetPolygon(target, -size);\n\n    // trim off self intersections!\n    let result = simplepolygon({\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          filterClosePoints(\n            offset.filter(\n              (v) => typeof v[0] === 'number' && typeof v[0] === 'number'\n            ),\n            0\n          ),\n        ],\n      },\n    })\n      .features.map((f) => f.geometry.coordinates[0])\n      .sort((a, b) => polygonArea(b) - polygonArea(a))[0]\n      .filter((p) => distanceToPolygon(p, target) >= size - 1);\n\n    return polygonClipping.difference(polygon, [result]);\n  } else {\n    console.warn('Only simple polygons can have a stroke applied.');\n  }\n\n  return polygon;\n}\n\nfunction radiusPolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = roundedPolygonVertices(clonePolygon(p), radius);\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction splinePolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = splinePolygonVertices(\n      clonePolygon(p),\n      radius,\n      true\n    );\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction simplifyPolygon(polygon, tolerance) {\n  extractNestedPolygons(polygon, (p) => {\n    const simplified = simplify(clonePolygon(p), tolerance);\n    const centroid = getPolygonCentroid([p]);\n\n    p.splice(simplified.length, p.length - simplified.length);\n\n    for (let i = 0; i < simplified.length; i++) {\n      p[i] = lerp(simplified[i], centroid, 0);\n\n      // p[i][0] += random(-4, 4);\n      // p[i][1] += random(-4, 4);\n    }\n\n    p[p.length - 1] = p[0];\n  });\n\n  return polygon;\n}\n\nexport {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n};\n","import { extractNestedPolygons } from '../utils';\n\nfunction buildPath(polygon) {\n  const verticeSets = extractNestedPolygons(polygon.vertices);\n\n  let basePathData = '';\n\n  for (const polygon of verticeSets) {\n    let pathData = '';\n\n    pathData += `M ${polygon[0][0].toFixed(2)} ${polygon[0][1].toFixed(2)}`;\n\n    for (let i = 1; i < polygon.length; i++) {\n      pathData += `L ${polygon[i][0].toFixed(2)} ${polygon[i][1].toFixed(2)}`;\n    }\n\n    pathData += `Z`;\n\n    basePathData += pathData;\n  }\n\n  return basePathData;\n}\n\nexport { buildPath };\n","import polygonClipping from 'polygon-clipping';\n\nimport { polygon } from '../polygon';\n\nfunction union(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.union(...vertices));\n}\n\nfunction difference(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.difference(...vertices));\n}\n\nfunction xor(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.xor(...vertices));\n}\n\nfunction intersection(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.intersection(...vertices));\n}\n\nexport { union, difference, xor, intersection };\n","import {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n} from './core';\n\nimport { buildPath } from '../rendering';\n\nimport { clonePolygon, getPolygonBounds, getPolygonArea } from '../utils';\nimport { intersection } from '../boolean-operations';\n\nclass BasePolygon {\n  constructor(vertices) {\n    this.vertices = vertices;\n  }\n\n  x(x) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  y(y) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  cx(x) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  cy(y) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  rotate(degrees = 0) {\n    this.vertices = rotatePolygon(clonePolygon(this.vertices), degrees);\n\n    return this;\n  }\n\n  scale(amountX = 1, amountY = null) {\n    if (amountY === null) {\n      amountY = amountX;\n    }\n\n    this.vertices = scalePolygon(clonePolygon(this.vertices), amountX, amountY);\n\n    return this;\n  }\n\n  offset(size) {\n    if (size >= 1) {\n      this.vertices = strokePolygon(clonePolygon(this.vertices), size);\n    }\n\n    return this;\n  }\n\n  radius(amount) {\n    if (amount >= 0) {\n      this.vertices = radiusPolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  spline(amount) {\n    if (amount > 0) {\n      this.vertices = splinePolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  simplify(tolerance = 16) {\n    this.vertices = simplifyPolygon(clonePolygon(this.vertices), tolerance);\n\n    return this;\n  }\n\n  checkIntersection(targets, amount = 1) {\n    // Wrap in a try/catch to account for occasional polygonClipping weirdness\n    try {\n      if (\n        targets.some(\n          (s) => !!intersection(s.clone(), this.clone()).vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 * amount))\n              .vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 / amount))\n              .vertices[0]\n        )\n      ) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch {\n      return true;\n    }\n  }\n\n  getBounds() {\n    return getPolygonBounds(this.vertices);\n  }\n\n  getArea() {\n    return getPolygonArea(this.vertices);\n  }\n\n  clone() {\n    return new BasePolygon(clonePolygon(this.vertices));\n  }\n\n  buildPath() {\n    return buildPath(this.clone());\n  }\n}\n\nexport { BasePolygon };\n","import quadratic from 'adaptive-quadratic-curve';\n\nfunction roundedPolygonVertices(points, radius) {\n  points = points.map((p) => ({ x: p[0], y: p[1] }));\n\n  if (radius === 0) {\n    radius = 0.0000001;\n  }\n\n  if (\n    points[0].x === points[points.length - 1].x &&\n    points[0].y === points[points.length - 1].y\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  const result = [];\n\n  const distance = (p1, p2) =>\n    Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n\n  const lerp = (a, b, x) => a + (b - a) * x;\n\n  const lerp2D = (p1, p2, t) => ({\n    x: lerp(p1.x, p2.x, t),\n    y: lerp(p1.y, p2.y, t),\n  });\n\n  const numPoints = points.length;\n\n  let corners = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    let lastPoint = points[i];\n    let thisPoint = points[(i + 1) % numPoints];\n    let nextPoint = points[(i + 2) % numPoints];\n\n    let lastEdgeLength = distance(lastPoint, thisPoint);\n    let lastOffsetDistance = Math.min(lastEdgeLength / 2, radius);\n    let start = lerp2D(\n      thisPoint,\n      lastPoint,\n      lastOffsetDistance / lastEdgeLength\n    );\n\n    let nextEdgeLength = distance(nextPoint, thisPoint);\n    let nextOffsetDistance = Math.min(nextEdgeLength / 2, radius);\n    let end = lerp2D(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n\n    corners.push([start, thisPoint, end]);\n  }\n\n  for (let [start, ctrl, end] of corners) {\n    result.push(\n      ...quadratic([start.x, start.y], [ctrl.x, ctrl.y], [end.x, end.y], 8)\n    );\n  }\n\n  return result;\n}\n\nexport { roundedPolygonVertices };\n","import { distBetweenPoints, filterClosePoints } from './index';\n\nimport bezier from 'adaptive-bezier-curve';\n\nfunction formatPoints(points, close) {\n  points = [...points];\n\n  if (!Array.isArray(points[0])) {\n    points = points.map(({ x, y }) => [x, y]);\n  }\n\n  if (close) {\n    const lastPoint = points[points.length - 1];\n    const secondToLastPoint = points[points.length - 2];\n\n    const firstPoint = points[0];\n    const secondPoint = points[1];\n\n    points.unshift(lastPoint);\n    points.unshift(secondToLastPoint);\n\n    points.push(firstPoint);\n    points.push(secondPoint);\n  }\n\n  return points.flat();\n}\n\nfunction splinePolygonVertices(points = [], tension = 1, close = true) {\n  if (\n    points[0][0] === points[points.length - 1][0] &&\n    points[0][1] === points[points.length - 1][1]\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  points = formatPoints(points, close);\n\n  const result = [];\n\n  const size = points.length;\n  const last = size - 4;\n\n  const startPointX = close ? points[2] : points[0];\n  const startPointY = close ? points[3] : points[1];\n\n  result.push([startPointX, startPointY]);\n\n  const startIteration = close ? 2 : 0;\n  const maxIteration = close ? size - 4 : size - 2;\n  const inc = 2;\n\n  const baseTension = tension;\n\n  for (let i = startIteration; i < maxIteration; i += inc) {\n    const x0 = i ? points[i - 2] : points[0];\n    const y0 = i ? points[i - 1] : points[1];\n\n    const x1 = points[i + 0];\n    const y1 = points[i + 1];\n\n    const x2 = points[i + 2];\n    const y2 = points[i + 3];\n\n    if (distBetweenPoints([x1, y1], [x2, y2]) < 8) {\n      tension = 0.0001;\n    } else {\n      tension = baseTension;\n    }\n\n    const x3 = i !== last ? points[i + 4] : x2;\n    const y3 = i !== last ? points[i + 5] : y2;\n\n    const cp1x = x1 + ((x2 - x0) / 6) * tension;\n    const cp1y = y1 + ((y2 - y0) / 6) * tension;\n\n    const cp2x = x2 - ((x3 - x1) / 6) * tension;\n    const cp2y = y2 - ((y3 - y1) / 6) * tension;\n\n    result.push(...bezier([x1, y1], [cp1x, cp1y], [cp2x, cp2y], [x2, y2], 8));\n  }\n\n  return filterClosePoints(result, 0);\n}\n\nexport { splinePolygonVertices };\n","import { BasePolygon } from './base-polygon';\n\nimport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n} from './core';\n\nfunction rect(width, height) {\n  const vertices = createRectPolygonVertices(width, height);\n\n  return new BasePolygon(vertices);\n}\n\nfunction ellipse(width, height, numPoints) {\n  const vertices = createEllipsePolygonVertices(width, height, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction circle(radius, numPoints) {\n  const vertices = createEllipsePolygonVertices(radius, radius, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction polygon(vertices) {\n  return new BasePolygon(vertices);\n}\n\nfunction line(points, width) {\n  const vertices = createLinePolygonVertices(points, width);\n\n  return new BasePolygon(vertices);\n}\n\nfunction quadtratic(start, c1, end, width, scale) {\n  const vertices = createQuadraticCurvePolygonVertices(\n    start,\n    c1,\n    end,\n    width,\n    scale\n  );\n\n  return new BasePolygon(vertices);\n}\n\nexport { rect, ellipse, circle, polygon, line, quadtratic };\n"],"names":["distBetweenPoints","p1","p2","a","b","Math","sqrt","filterClosePoints","arr","d","result","i","length","currentPoint","some","p","push","extractNestedPolygons","polygon","callback","polygons","isNaN","current","j","clonePolygon","JSON","parse","stringify","getPolygonBounds","vertices","flat","topLeft","bottomRight","polygonBounds","x","y","width","height","line2Polygon","getOffsets","thickness","dx","dy","scale","getIntersection","a1","b1","a2","b2","k1","k2","abs","m1","points","pt","Object","prototype","toString","call","t","off","off2","isFirst","isLast","prevA","prevB","interA","interB","p0a","p1a","p0b","p1b","poly","il","unshift","filter","lineToPolygon","line","createEllipsePolygonVertices","numPoints","angleStep","PI","cos","sin","translatePolygonTopLeft","targetX","targetY","bounds","currentTopLeft","targetTopLeft","dist","angle","atan2","polygonTranslate","translatePolygonCenter","buildPath","verticeSets","basePathData","pathData","toFixed","union","map","polygonClipping","difference","xor","intersection","BasePolygon","constructor","this","cx","cy","rotate","degrees","r","polygonRotate","rotatePolygon","amountX","amountY","sX","polygonScaleX","sY","polygonScaleY","scalePolygon","offset","size","target","formattedPolygon","v","hasPerformedFixup","slice","offsetPolygonFn","offsetPolygon","simplepolygon","type","geometry","coordinates","features","f","sort","polygonArea","distanceToPolygon","console","warn","strokePolygon","radius","amount","polygonWithRadius","distance","lerp","lerp2D","corners","lastPoint","thisPoint","nextPoint","lastEdgeLength","start","min","nextEdgeLength","end","ctrl","quadratic","roundedPolygonVertices","radiusPolygon","spline","tension","close","Array","isArray","secondToLastPoint","firstPoint","secondPoint","formatPoints","last","maxIteration","baseTension","x0","y0","x1","y1","x2","y2","bezier","splinePolygonVertices","splinePolygon","simplify","tolerance","simplified","centroid","polygonCentroid","getPolygonCentroid","splice","position","simplifyPolygon","checkIntersection","targets","s","clone","getBounds","getArea","getPolygonArea","rect","createRectPolygonVertices","ellipse","circle","createLinePolygonVertices","quadtratic","c1","createQuadraticCurvePolygonVertices"],"mappings":"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"}