{"version":3,"file":"shapes.module.js","sources":["../lib/utils/vertex-utils.js","../lib/utils/polygon-utils.js","../lib/utils/line-to-polygon.js","../lib/polygon/core/create-polygon-vertices.js","../lib/polygon/core/transform-polygon-vertices.js","../lib/rendering/build-path.js","../lib/boolean-operations/index.js","../lib/polygon/base-polygon.js","../lib/utils/rounded-polygon-vertices.js","../lib/utils/spline-polygon-vertices.js","../lib/polygon/index.js"],"sourcesContent":["/**\n * Get the distance beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Distance beween Point 1 & Point 2.\n */\nfunction distBetweenPoints(p1, p2) {\n  var a = p1[0] - p2[0];\n  var b = p1[1] - p2[1];\n\n  return Math.sqrt(a * a + b * b);\n}\n\n/**\n * Get the angle beween two [x, y] points.\n *\n * @param {array} p1 - Point 1.\n * @param {array} p2 - Point 2.\n *\n * @returns {number} Angle beween Point 1 & Point 2.\n */\nfunction angleBetweenPoints(p1, p2) {\n  return (Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180) / Math.PI;\n}\n\nfunction filterClosePoints(arr, d) {\n  const result = [arr[0]];\n\n  for (let i = 1; i < arr.length; i++) {\n    const currentPoint = arr[i];\n\n    if (!result.some((p) => distBetweenPoints(p, currentPoint) <= d)) {\n      result.push(currentPoint);\n    }\n  }\n\n  return result;\n}\n\nfunction lerp(position, target, amt) {\n  return [\n    (position[0] += (target[0] - position[0]) * amt),\n    (position[1] += (target[1] - position[1]) * amt),\n  ];\n}\n\nexport { distBetweenPoints, angleBetweenPoints, filterClosePoints, lerp };\n","import { polygonBounds, polygonCentroid, polygonArea } from 'geometric';\nimport offsetPolygonFn from 'offset-polygon';\n\n/**\n * Polygons can be made up of lots of nested polygon arrays (often after boolean operations).\n * This function is useful for performing operations on every nested polygon within a polygon.\n *\n * @param {array} polygon - Base polygon to extract nested polygons from.\n * @param {function} callback - Runs for each unique polygon. Useful for modifying in-place.\n *\n * @returns {array} A flat array of polygons [[p1], [[p1]] ...].\n */\nfunction extractNestedPolygons(polygon, callback) {\n  if (polygon.length === 0) return [];\n\n  const polygons = [];\n\n  // Is this just a standalone polygon? [[x, y], [x, y]...]\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    if (!!callback) {\n      callback(polygon[0]);\n    } else {\n      polygons.push(polygon[0]);\n    }\n  } else {\n    // This is a nested polygon!\n    for (let i = 0; i < polygon.length; i++) {\n      const current = polygon[i];\n\n      // There is only one nested polygon in this array\n      if (current.length === 1) {\n        if (!!callback) {\n          callback(current[0]);\n        } else {\n          polygons.push(current[0]);\n        }\n      } else {\n        // There is more than one nested polygon in this array\n        for (let j = 0; j < current.length; j++) {\n          if (!!callback) {\n            callback(current[j]);\n          } else {\n            polygons.push(current[j]);\n          }\n        }\n      }\n    }\n  }\n\n  return polygons;\n}\n\n/**\n * Create deep clone of a polygon.\n *\n * @param {array} polygon - Polygon to clone.\n *\n * @returns {array} Deep clone of the polygon input.\n */\nfunction clonePolygon(polygon) {\n  return JSON.parse(JSON.stringify(polygon));\n}\n\n/**\n * Get a polygon's bounds.\n *\n * @param {array} polygon\n *\n * @returns {object} Polygon's bounding rect ({ x, y, width, height }).\n */\nfunction getPolygonBounds(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  const [topLeft, bottomRight] = polygonBounds(vertices);\n\n  return {\n    x: topLeft[0],\n    y: topLeft[1],\n    width: bottomRight[0] - topLeft[0],\n    height: bottomRight[1] - topLeft[1],\n  };\n}\n\nfunction getPolygonArea(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonArea(vertices);\n}\n\nfunction getPolygonCentroid(polygon) {\n  const vertices = extractNestedPolygons(polygon).flat();\n\n  return polygonCentroid(vertices);\n}\n\nfunction offsetPolygon(polygon, size) {\n  let formattedPolygon = polygon.map((v) => ({ x: v[0], y: v[1] }));\n  let hasPerformedFixup = false;\n\n  if (\n    JSON.stringify(formattedPolygon[0]) ===\n    JSON.stringify(formattedPolygon[formattedPolygon.length - 1])\n  ) {\n    formattedPolygon = formattedPolygon.slice(0, formattedPolygon.length - 1);\n\n    hasPerformedFixup = true;\n  }\n\n  const offset = offsetPolygonFn(formattedPolygon, size, 0);\n\n  if (hasPerformedFixup) {\n    offset.push(offset[0]);\n  }\n\n  return offset.map((v) => [v.x, v.y]);\n}\n\nexport {\n  extractNestedPolygons,\n  clonePolygon,\n  getPolygonBounds,\n  offsetPolygon,\n  getPolygonCentroid,\n  getPolygonArea,\n};\n","var line2Polygon = (function () {\n  function getOffsets(a, b, thickness) {\n    var dx = b.x - a.x,\n      dy = b.y - a.y,\n      len = Math.sqrt(dx * dx + dy * dy),\n      scale = thickness / (2 * len);\n    return {\n      x: -scale * dy,\n      y: scale * dx,\n    };\n  }\n\n  function getIntersection(a1, b1, a2, b2) {\n    // directional constants\n    var k1 = (b1.y - a1.y) / (b1.x - a1.x),\n      k2 = (b2.y - a2.y) / (b2.x - a2.x);\n\n    // if the directional constants are equal, the lines are parallel\n    if (k1 === k2 || Math.abs(k1 - k2) < 0.00001) {\n      return;\n    }\n\n    // y offset constants for both lines\n    var m1 = a1.y - k1 * a1.x;\n    var m2 = a2.y - k2 * a2.x;\n\n    // compute x\n    var x = (m1 - m2) / (k2 - k1);\n\n    // use y = k * x + m to get y coordinate\n    var y = k1 * x + m1;\n\n    return { x: x, y: y };\n  }\n\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n\n  function me(points, thickness) {\n    //Convert points into json notation\n    var arr = [];\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      arr.push({\n        x: pt[0],\n        y: pt[1],\n      });\n    }\n    points = arr;\n\n    //Convert thickness into an array as needed\n    if (!isArray(thickness)) {\n      var t = thickness;\n      thickness = [];\n      for (var i = 0; i < points.length; i++) {\n        thickness.push(t);\n      }\n    }\n\n    var off,\n      off2,\n      poly = [],\n      isFirst,\n      isLast,\n      prevA,\n      prevB,\n      interA,\n      interB,\n      p0a,\n      p1a,\n      p0b,\n      p1b;\n\n    for (var i = 0, il = points.length - 1; i < il; i++) {\n      isFirst = !i;\n      isLast = i === points.length - 2;\n\n      off = getOffsets(points[i], points[i + 1], thickness[i]);\n      off2 = getOffsets(points[i], points[i + 1], thickness[i + 1]);\n\n      p0a = { x: points[i].x + off.x, y: points[i].y + off.y };\n      p1a = { x: points[i + 1].x + off2.x, y: points[i + 1].y + off2.y };\n\n      p0b = { x: points[i].x - off.x, y: points[i].y - off.y };\n      p1b = { x: points[i + 1].x - off2.x, y: points[i + 1].y - off2.y };\n\n      if (!isFirst) {\n        interA = getIntersection(prevA[0], prevA[1], p0a, p1a);\n        if (interA) {\n          poly.unshift(interA);\n        }\n        interB = getIntersection(prevB[0], prevB[1], p0b, p1b);\n        if (interB) {\n          poly.push(interB);\n        }\n      }\n\n      if (isFirst) {\n        poly.unshift(p0a);\n        poly.push(p0b);\n      }\n\n      if (isLast) {\n        poly.unshift(p1a);\n        poly.push(p1b);\n      }\n\n      if (!isLast) {\n        prevA = [p0a, p1a];\n        prevB = [p0b, p1b];\n      }\n    }\n\n    for (var i = 0; i < poly.length; i++) {\n      var pt = poly[i];\n      poly[i] = [pt.x, pt.y];\n    }\n    poly.push(poly[0]);\n\n    return poly.filter((x) => !isNaN(x[0]) && !isNaN(x[1]));\n  }\n\n  return me;\n})();\n\nfunction lineToPolygon(line, width) {\n  return line2Polygon(line, width);\n}\n\nexport { lineToPolygon };\n","import { lineToPolygon } from '../../utils';\nimport quadratic from 'adaptive-quadratic-curve';\n\nfunction createRectPolygonVertices(width, height) {\n  const vertices = [\n    [0, 0],\n    [width, 0],\n    [width, height],\n    [0, height],\n    [0, 0],\n  ];\n\n  return [vertices];\n}\n\nfunction createEllipsePolygonVertices(width, height, numPoints = 64) {\n  const vertices = [];\n  const angleStep = (Math.PI * 2) / numPoints;\n\n  for (let i = 1; i <= numPoints; i++) {\n    vertices.push([\n      (Math.cos(i * angleStep) * width) / 2 + width / 2,\n      (Math.sin(i * angleStep) * height) / 2 + height / 2,\n    ]);\n  }\n\n  vertices.push(vertices[0]);\n\n  return [vertices];\n}\n\nfunction createLinePolygonVertices(points, width = 1) {\n  return [lineToPolygon(points, width)];\n}\n\nfunction createQuadraticCurvePolygonVertices(\n  start,\n  c1,\n  end,\n  width = 1,\n  scale = 8\n) {\n  return [lineToPolygon(quadratic(start, c1, end, scale), width)];\n}\n\nexport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n};\n","import {\n  polygonTranslate,\n  polygonRotate,\n  polygonScaleX,\n  polygonScaleY,\n  polygonArea,\n} from 'geometric';\n\nimport polygonClipping from 'polygon-clipping';\nimport simplepolygon from 'simplepolygon';\nimport simplify from 'simplify-path';\n\nimport {\n  distBetweenPoints,\n  angleBetweenPoints,\n  getPolygonBounds,\n  extractNestedPolygons,\n  offsetPolygon,\n  clonePolygon,\n  roundedPolygonVertices,\n  splinePolygonVertices,\n  filterClosePoints,\n  lerp,\n  getPolygonCentroid,\n} from '../../utils';\n\nimport { distanceToPolygon } from 'distance-to-polygon';\n\nfunction translatePolygonTopLeft(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  if (targetX === null) {\n    targetX = bounds.x;\n  }\n\n  if (targetY === null) {\n    targetY = bounds.y;\n  }\n\n  const currentTopLeft = [bounds.x, bounds.y];\n  const targetTopLeft = [targetX, targetY];\n\n  const dist = distBetweenPoints(currentTopLeft, targetTopLeft);\n  const angle = angleBetweenPoints(currentTopLeft, targetTopLeft);\n\n  extractNestedPolygons(polygon, (p) => {\n    const t = polygonTranslate(p, angle, dist);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < t.length; i++) p[i] = t[i];\n  });\n\n  return polygon;\n}\n\nfunction translatePolygonCenter(polygon, targetX, targetY) {\n  const bounds = getPolygonBounds(polygon);\n\n  const targetTopLeft = [\n    targetX === null ? bounds.x : targetX - bounds.width / 2,\n    targetY === null ? bounds.y : targetY - bounds.height / 2,\n  ];\n\n  return translatePolygonTopLeft(polygon, targetTopLeft[0], targetTopLeft[1]);\n}\n\nfunction rotatePolygon(polygon, angle) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const r = polygonRotate(p, angle, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < r.length; i++) p[i] = r[i];\n  });\n\n  return polygon;\n}\n\nfunction scalePolygon(polygon, amountX = 1, amountY = 1) {\n  const bounds = getPolygonBounds(polygon);\n\n  extractNestedPolygons(polygon, (p) => {\n    const sX = polygonScaleX(p, amountX, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    const sY = polygonScaleY(sX, amountY, [\n      bounds.x + bounds.width / 2,\n      bounds.y + bounds.height / 2,\n    ]);\n\n    // update vertices in place to preserve polygon structure\n    for (let i = 0; i < sY.length; i++) p[i] = sY[i];\n  });\n\n  return polygon;\n}\n\nfunction strokePolygon(polygon, size = 1) {\n  let target = null;\n\n  if (!isNaN(polygon[0][0][0]) && !isNaN(polygon[0][0][1])) {\n    target = polygon[0];\n  } else if (polygon.length === 1 && polygon[0].length === 1) {\n    target = polygon[0][0];\n  }\n\n  if (target) {\n    const offset = offsetPolygon(target, -size);\n\n    // trim off self intersections!\n    let result = simplepolygon({\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [\n          filterClosePoints(\n            offset.filter(\n              (v) => typeof v[0] === 'number' && typeof v[0] === 'number'\n            ),\n            0\n          ),\n        ],\n      },\n    })\n      .features.map((f) => f.geometry.coordinates[0])\n      .sort((a, b) => polygonArea(b) - polygonArea(a))[0]\n      .filter((p) => distanceToPolygon(p, target) >= size - 1);\n\n    return polygonClipping.difference(polygon, [result]);\n  } else {\n    console.warn('Only simple polygons can have a stroke applied.');\n  }\n\n  return polygon;\n}\n\nfunction radiusPolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = roundedPolygonVertices(clonePolygon(p), radius);\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction splinePolygon(polygon, radius) {\n  extractNestedPolygons(polygon, (p) => {\n    const polygonWithRadius = splinePolygonVertices(\n      clonePolygon(p),\n      radius,\n      true\n    );\n\n    for (let i = 0; i < polygonWithRadius.length; i++) {\n      p[i] = polygonWithRadius[i];\n    }\n  });\n\n  return polygon;\n}\n\nfunction simplifyPolygon(polygon, tolerance) {\n  extractNestedPolygons(polygon, (p) => {\n    const simplified = simplify(clonePolygon(p), tolerance);\n    const centroid = getPolygonCentroid([p]);\n\n    p.splice(simplified.length, p.length - simplified.length);\n\n    for (let i = 0; i < simplified.length; i++) {\n      p[i] = lerp(simplified[i], centroid, 0);\n\n      // p[i][0] += random(-4, 4);\n      // p[i][1] += random(-4, 4);\n    }\n\n    p[p.length - 1] = p[0];\n  });\n\n  return polygon;\n}\n\nexport {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n};\n","import { extractNestedPolygons } from '../utils';\n\nfunction buildPath(polygon) {\n  const verticeSets = extractNestedPolygons(polygon.vertices);\n\n  let basePathData = '';\n\n  for (const polygon of verticeSets) {\n    let pathData = '';\n\n    pathData += `M ${polygon[0][0].toFixed(2)} ${polygon[0][1].toFixed(2)}`;\n\n    for (let i = 1; i < polygon.length; i++) {\n      pathData += `L ${polygon[i][0].toFixed(2)} ${polygon[i][1].toFixed(2)}`;\n    }\n\n    pathData += `Z`;\n\n    basePathData += pathData;\n  }\n\n  return basePathData;\n}\n\nexport { buildPath };\n","import polygonClipping from 'polygon-clipping';\n\nimport { polygon } from '../polygon';\n\nfunction union(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.union(...vertices));\n}\n\nfunction difference(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.difference(...vertices));\n}\n\nfunction xor(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.xor(...vertices));\n}\n\nfunction intersection(...polygons) {\n  const vertices = polygons.map((p) => p.vertices);\n\n  return polygon(polygonClipping.intersection(...vertices));\n}\n\nexport { union, difference, xor, intersection };\n","import {\n  translatePolygonTopLeft,\n  translatePolygonCenter,\n  rotatePolygon,\n  scalePolygon,\n  strokePolygon,\n  radiusPolygon,\n  splinePolygon,\n  simplifyPolygon,\n} from './core';\n\nimport { buildPath } from '../rendering';\n\nimport { clonePolygon, getPolygonBounds, getPolygonArea } from '../utils';\nimport { intersection } from '../boolean-operations';\n\nclass BasePolygon {\n  constructor(vertices) {\n    this.vertices = vertices;\n  }\n\n  x(x) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  y(y) {\n    this.vertices = translatePolygonTopLeft(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  cx(x) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      x,\n      null\n    );\n\n    return this;\n  }\n\n  cy(y) {\n    this.vertices = translatePolygonCenter(\n      clonePolygon(this.vertices),\n      null,\n      y\n    );\n\n    return this;\n  }\n\n  rotate(degrees = 0) {\n    this.vertices = rotatePolygon(clonePolygon(this.vertices), degrees);\n\n    return this;\n  }\n\n  scale(amountX = 1, amountY = null) {\n    if (amountY === null) {\n      amountY = amountX;\n    }\n\n    this.vertices = scalePolygon(clonePolygon(this.vertices), amountX, amountY);\n\n    return this;\n  }\n\n  offset(size) {\n    if (size >= 1) {\n      this.vertices = strokePolygon(clonePolygon(this.vertices), size);\n    }\n\n    return this;\n  }\n\n  radius(amount) {\n    if (amount >= 0) {\n      this.vertices = radiusPolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  spline(amount) {\n    if (amount > 0) {\n      this.vertices = splinePolygon(clonePolygon(this.vertices), amount);\n    }\n\n    return this;\n  }\n\n  simplify(tolerance = 16) {\n    this.vertices = simplifyPolygon(clonePolygon(this.vertices), tolerance);\n\n    return this;\n  }\n\n  checkIntersection(targets, amount = 1) {\n    // Wrap in a try/catch to account for occasional polygonClipping weirdness\n    try {\n      if (\n        targets.some(\n          (s) => !!intersection(s.clone(), this.clone()).vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 * amount))\n              .vertices[0]\n        ) ||\n        targets.some(\n          (s) =>\n            !!intersection(s.clone(), this.clone().scale(1 / amount))\n              .vertices[0]\n        )\n      ) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch {\n      return true;\n    }\n  }\n\n  getBounds() {\n    return getPolygonBounds(this.vertices);\n  }\n\n  getArea() {\n    return getPolygonArea(this.vertices);\n  }\n\n  clone() {\n    return new BasePolygon(clonePolygon(this.vertices));\n  }\n\n  buildPath() {\n    return buildPath(this.clone());\n  }\n}\n\nexport { BasePolygon };\n","import quadratic from 'adaptive-quadratic-curve';\n\nfunction roundedPolygonVertices(points, radius) {\n  points = points.map((p) => ({ x: p[0], y: p[1] }));\n\n  if (radius === 0) {\n    radius = 0.0000001;\n  }\n\n  if (\n    points[0].x === points[points.length - 1].x &&\n    points[0].y === points[points.length - 1].y\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  const result = [];\n\n  const distance = (p1, p2) =>\n    Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);\n\n  const lerp = (a, b, x) => a + (b - a) * x;\n\n  const lerp2D = (p1, p2, t) => ({\n    x: lerp(p1.x, p2.x, t),\n    y: lerp(p1.y, p2.y, t),\n  });\n\n  const numPoints = points.length;\n\n  let corners = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    let lastPoint = points[i];\n    let thisPoint = points[(i + 1) % numPoints];\n    let nextPoint = points[(i + 2) % numPoints];\n\n    let lastEdgeLength = distance(lastPoint, thisPoint);\n    let lastOffsetDistance = Math.min(lastEdgeLength / 2, radius);\n    let start = lerp2D(\n      thisPoint,\n      lastPoint,\n      lastOffsetDistance / lastEdgeLength\n    );\n\n    let nextEdgeLength = distance(nextPoint, thisPoint);\n    let nextOffsetDistance = Math.min(nextEdgeLength / 2, radius);\n    let end = lerp2D(thisPoint, nextPoint, nextOffsetDistance / nextEdgeLength);\n\n    corners.push([start, thisPoint, end]);\n  }\n\n  for (let [start, ctrl, end] of corners) {\n    result.push(\n      ...quadratic([start.x, start.y], [ctrl.x, ctrl.y], [end.x, end.y], 8)\n    );\n  }\n\n  return result;\n}\n\nexport { roundedPolygonVertices };\n","import { distBetweenPoints, filterClosePoints } from './index';\n\nimport bezier from 'adaptive-bezier-curve';\n\nfunction formatPoints(points, close) {\n  points = [...points];\n\n  if (!Array.isArray(points[0])) {\n    points = points.map(({ x, y }) => [x, y]);\n  }\n\n  if (close) {\n    const lastPoint = points[points.length - 1];\n    const secondToLastPoint = points[points.length - 2];\n\n    const firstPoint = points[0];\n    const secondPoint = points[1];\n\n    points.unshift(lastPoint);\n    points.unshift(secondToLastPoint);\n\n    points.push(firstPoint);\n    points.push(secondPoint);\n  }\n\n  return points.flat();\n}\n\nfunction splinePolygonVertices(points = [], tension = 1, close = true) {\n  if (\n    points[0][0] === points[points.length - 1][0] &&\n    points[0][1] === points[points.length - 1][1]\n  ) {\n    points = points.slice(0, points.length - 1);\n  }\n\n  points = formatPoints(points, close);\n\n  const result = [];\n\n  const size = points.length;\n  const last = size - 4;\n\n  const startPointX = close ? points[2] : points[0];\n  const startPointY = close ? points[3] : points[1];\n\n  result.push([startPointX, startPointY]);\n\n  const startIteration = close ? 2 : 0;\n  const maxIteration = close ? size - 4 : size - 2;\n  const inc = 2;\n\n  const baseTension = tension;\n\n  for (let i = startIteration; i < maxIteration; i += inc) {\n    const x0 = i ? points[i - 2] : points[0];\n    const y0 = i ? points[i - 1] : points[1];\n\n    const x1 = points[i + 0];\n    const y1 = points[i + 1];\n\n    const x2 = points[i + 2];\n    const y2 = points[i + 3];\n\n    if (distBetweenPoints([x1, y1], [x2, y2]) < 8) {\n      tension = 0.0001;\n    } else {\n      tension = baseTension;\n    }\n\n    const x3 = i !== last ? points[i + 4] : x2;\n    const y3 = i !== last ? points[i + 5] : y2;\n\n    const cp1x = x1 + ((x2 - x0) / 6) * tension;\n    const cp1y = y1 + ((y2 - y0) / 6) * tension;\n\n    const cp2x = x2 - ((x3 - x1) / 6) * tension;\n    const cp2y = y2 - ((y3 - y1) / 6) * tension;\n\n    result.push(...bezier([x1, y1], [cp1x, cp1y], [cp2x, cp2y], [x2, y2], 8));\n  }\n\n  return filterClosePoints(result, 0);\n}\n\nexport { splinePolygonVertices };\n","import { BasePolygon } from './base-polygon';\n\nimport {\n  createRectPolygonVertices,\n  createEllipsePolygonVertices,\n  createLinePolygonVertices,\n  createQuadraticCurvePolygonVertices,\n} from './core';\n\nfunction rect(width, height) {\n  const vertices = createRectPolygonVertices(width, height);\n\n  return new BasePolygon(vertices);\n}\n\nfunction ellipse(width, height, numPoints) {\n  const vertices = createEllipsePolygonVertices(width, height, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction circle(radius, numPoints) {\n  const vertices = createEllipsePolygonVertices(radius, radius, numPoints);\n\n  return new BasePolygon(vertices);\n}\n\nfunction polygon(vertices) {\n  return new BasePolygon(vertices);\n}\n\nfunction line(points, width) {\n  const vertices = createLinePolygonVertices(points, width);\n\n  return new BasePolygon(vertices);\n}\n\nfunction quadtratic(start, c1, end, width, scale) {\n  const vertices = createQuadraticCurvePolygonVertices(\n    start,\n    c1,\n    end,\n    width,\n    scale\n  );\n\n  return new BasePolygon(vertices);\n}\n\nexport { rect, ellipse, circle, polygon, line, quadtratic };\n"],"names":["distBetweenPoints","p1","p2","a","b","Math","sqrt","filterClosePoints","arr","d","result","i","currentPoint","some","p","push","length","extractNestedPolygons","polygon","callback","polygons","isNaN","current","j","clonePolygon","JSON","parse","stringify","getPolygonBounds","vertices","flat","polygonBounds","topLeft","bottomRight","x","y","width","height","line2Polygon","getOffsets","thickness","dx","dy","scale","getIntersection","a1","b1","a2","b2","k1","k2","abs","m1","points","pt","Object","prototype","toString","call","t","off","off2","isFirst","isLast","prevA","prevB","interA","interB","p0a","p1a","p0b","p1b","poly","il","unshift","filter","lineToPolygon","line","createEllipsePolygonVertices","numPoints","angleStep","PI","cos","sin","translatePolygonTopLeft","targetX","targetY","bounds","currentTopLeft","targetTopLeft","dist","angle","atan2","polygonTranslate","translatePolygonCenter","buildPath","basePathData","pathData","toFixed","union","map","polygonClipping","difference","xor","intersection","BasePolygon","this","cx","cy","rotate","degrees","r","polygonRotate","rotatePolygon","amountX","amountY","sX","polygonScaleX","sY","polygonScaleY","scalePolygon","offset","size","target","formattedPolygon","v","hasPerformedFixup","slice","offsetPolygonFn","offsetPolygon","simplepolygon","type","geometry","coordinates","features","f","sort","polygonArea","distanceToPolygon","console","warn","strokePolygon","radius","amount","polygonWithRadius","distance","lerp","lerp2D","corners","lastPoint","thisPoint","nextPoint","lastEdgeLength","start","min","nextEdgeLength","end","ctrl","quadratic","roundedPolygonVertices","radiusPolygon","spline","tension","close","Array","isArray","secondToLastPoint","firstPoint","secondPoint","formatPoints","last","maxIteration","baseTension","x0","y0","x1","y1","x2","y2","bezier","splinePolygonVertices","splinePolygon","simplify","tolerance","position","simplified","centroid","polygonCentroid","getPolygonCentroid","splice","simplifyPolygon","checkIntersection","targets","s","clone","_this","getBounds","getArea","getPolygonArea","rect","createRectPolygonVertices","ellipse","circle","createLinePolygonVertices","quadtratic","c1","createQuadraticCurvePolygonVertices"],"mappings":"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"}