import{polygonArea as t,polygonBounds as e,polygonCentroid as n,polygonTranslate as r,polygonRotate as i,polygonScaleX as s,polygonScaleY as o}from"geometric";import c from"offset-polygon";import u from"adaptive-quadratic-curve";import h from"adaptive-bezier-curve";import l from"polygon-clipping";import f from"simplepolygon";import y from"simplify-path";import{distanceToPolygon as a}from"distance-to-polygon";function p(t,e){var n=t[0]-e[0],r=t[1]-e[1];return Math.sqrt(n*n+r*r)}function g(t,e){const n=[t[0]];for(let r=1;r<t.length;r++){const i=t[r];n.some(t=>p(t,i)<=e)||n.push(i)}return n}function x(t,e){if(0===t.length)return[];const n=[];if(isNaN(t[0][0][0])||isNaN(t[0][0][1]))for(let r=0;r<t.length;r++){const i=t[r];if(1===i.length)e?e(i[0]):n.push(i[0]);else for(let t=0;t<i.length;t++)e?e(i[t]):n.push(i[t])}else e?e(t[0]):n.push(t[0]);return n}function v(t){return JSON.parse(JSON.stringify(t))}function m(t){const n=x(t).flat(),[r,i]=e(n);return{x:r[0],y:r[1],width:i[0]-r[0],height:i[1]-r[1]}}var d=function(){function t(t,e,n){var r=e.x-t.x,i=e.y-t.y,s=n/(2*Math.sqrt(r*r+i*i));return{x:-s*i,y:s*r}}function e(t,e,n,r){var i=(e.y-t.y)/(e.x-t.x),s=(r.y-n.y)/(r.x-n.x);if(!(i===s||Math.abs(i-s)<1e-5)){var o=t.y-i*t.x,c=(o-(n.y-s*n.x))/(s-i);return{x:c,y:i*c+o}}}return function(n,r){for(var i=[],s=0;s<n.length;s++)i.push({x:(w=n[s])[0],y:w[1]});if(n=i,"[object Array]"!==Object.prototype.toString.call(r)){var o=r;for(r=[],s=0;s<n.length;s++)r.push(o)}for(var c,u,h,l,f,y,a,p,g,x,v,m,d=[],N=(s=0,n.length-1);s<N;s++)h=!s,l=s===n.length-2,c=t(n[s],n[s+1],r[s]),u=t(n[s],n[s+1],r[s+1]),g={x:n[s].x+c.x,y:n[s].y+c.y},x={x:n[s+1].x+u.x,y:n[s+1].y+u.y},v={x:n[s].x-c.x,y:n[s].y-c.y},m={x:n[s+1].x-u.x,y:n[s+1].y-u.y},h||((a=e(f[0],f[1],g,x))&&d.unshift(a),(p=e(y[0],y[1],v,m))&&d.push(p)),h&&(d.unshift(g),d.push(v)),l&&(d.unshift(x),d.push(m)),l||(f=[g,x],y=[v,m]);for(s=0;s<d.length;s++){var w;d[s]=[(w=d[s]).x,w.y]}return d.push(d[0]),d.filter(t=>!isNaN(t[0])&&!isNaN(t[1]))}}();function N(t,e){return d(t,e)}function w(t,e,n=64){const r=[],i=2*Math.PI/n;for(let s=1;s<=n;s++)r.push([Math.cos(s*i)*t/2+t/2,Math.sin(s*i)*e/2+e/2]);return r.push(r[0]),[r]}function M(t,e,n){const i=m(t);null===e&&(e=i.x),null===n&&(n=i.y);const s=[i.x,i.y],o=[e,n],c=p(s,o),u=(h=s,l=o,180*Math.atan2(l[1]-h[1],l[0]-h[0])/Math.PI);var h,l;return x(t,t=>{const e=r(t,u,c);for(let n=0;n<e.length;n++)t[n]=e[n]}),t}function b(t,e,n){const r=m(t),i=[null===e?r.x:e-r.width/2,null===n?r.y:n-r.height/2];return M(t,i[0],i[1])}function O(t){const e=x(t.vertices);let n="";for(const t of e){let e="";e+=`M ${t[0][0].toFixed(2)} ${t[0][1].toFixed(2)}`;for(let n=1;n<t.length;n++)e+=`L ${t[n][0].toFixed(2)} ${t[n][1].toFixed(2)}`;e+="Z",n+=e}return n}function F(...t){const e=t.map(t=>t.vertices);return j(l.union(...e))}function S(...t){const e=t.map(t=>t.vertices);return j(l.difference(...e))}function q(...t){const e=t.map(t=>t.vertices);return j(l.xor(...e))}function A(...t){const e=t.map(t=>t.vertices);return j(l.intersection(...e))}class J{constructor(t){this.vertices=t}x(t){return this.vertices=M(v(this.vertices),t,null),this}y(t){return this.vertices=M(v(this.vertices),null,t),this}cx(t){return this.vertices=b(v(this.vertices),t,null),this}cy(t){return this.vertices=b(v(this.vertices),null,t),this}rotate(t=0){return this.vertices=function(t,e){const n=m(t);return x(t,t=>{const r=i(t,e,[n.x+n.width/2,n.y+n.height/2]);for(let e=0;e<r.length;e++)t[e]=r[e]}),t}(v(this.vertices),t),this}scale(t=1,e=null){return null===e&&(e=t),this.vertices=function(t,e=1,n=1){const r=m(t);return x(t,t=>{const i=s(t,e,[r.x+r.width/2,r.y+r.height/2]),c=o(i,n,[r.x+r.width/2,r.y+r.height/2]);for(let e=0;e<c.length;e++)t[e]=c[e]}),t}(v(this.vertices),t,e),this}offset(e){return e>=1&&(this.vertices=function(e,n=1){let r=null;if(isNaN(e[0][0][0])||isNaN(e[0][0][1])?1===e.length&&1===e[0].length&&(r=e[0][0]):r=e[0],r){const i=function(t,e){let n=t.map(t=>({x:t[0],y:t[1]})),r=!1;JSON.stringify(n[0])===JSON.stringify(n[n.length-1])&&(n=n.slice(0,n.length-1),r=!0);const i=c(n,e,0);return r&&i.push(i[0]),i.map(t=>[t.x,t.y])}(r,-n);let s=f({type:"Feature",geometry:{type:"Polygon",coordinates:[g(i.filter(t=>"number"==typeof t[0]&&"number"==typeof t[0]),0)]}}).features.map(t=>t.geometry.coordinates[0]).sort((e,n)=>t(n)-t(e))[0].filter(t=>a(t,r)>=n-1);return l.difference(e,[s])}return console.warn("Only simple polygons can have a stroke applied."),e}(v(this.vertices),e)),this}radius(t){return t>=0&&(this.vertices=function(t,e){return x(t,t=>{const n=function(t,e){0===e&&(e=1e-7),(t=t.map(t=>({x:t[0],y:t[1]})))[0].x===t[t.length-1].x&&t[0].y===t[t.length-1].y&&(t=t.slice(0,t.length-1));const n=[],r=(t,e)=>Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2),i=(t,e,n)=>t+(e-t)*n,s=(t,e,n)=>({x:i(t.x,e.x,n),y:i(t.y,e.y,n)}),o=t.length;let c=[];for(let n=0;n<o;n++){let i=t[n],u=t[(n+1)%o],h=t[(n+2)%o],l=r(i,u),f=s(u,i,Math.min(l/2,e)/l),y=r(h,u),a=s(u,h,Math.min(y/2,e)/y);c.push([f,u,a])}for(let[t,e,r]of c)n.push(...u([t.x,t.y],[e.x,e.y],[r.x,r.y],8));return n}(v(t),e);for(let e=0;e<n.length;e++)t[e]=n[e]}),t}(v(this.vertices),t)),this}spline(t){return t>0&&(this.vertices=function(t,e){return x(t,t=>{const n=function(t=[],e=1,n=!0){t[0][0]===t[t.length-1][0]&&t[0][1]===t[t.length-1][1]&&(t=t.slice(0,t.length-1)),t=function(t,e){if(t=[...t],Array.isArray(t[0])||(t=t.map(({x:t,y:e})=>[t,e])),e){const e=t[t.length-2],n=t[0],r=t[1];t.unshift(t[t.length-1]),t.unshift(e),t.push(n),t.push(r)}return t.flat()}(t,n);const r=[],i=t.length,s=i-4;r.push([n?t[2]:t[0],n?t[3]:t[1]]);const o=n?i-4:i-2,c=e;for(let i=n?2:0;i<o;i+=2){const n=i?t[i-2]:t[0],o=i?t[i-1]:t[1],u=t[i+0],l=t[i+1],f=t[i+2],y=t[i+3];e=p([u,l],[f,y])<8?1e-4:c,r.push(...h([u,l],[u+(f-n)/6*e,l+(y-o)/6*e],[f-((i!==s?t[i+4]:f)-u)/6*e,y-((i!==s?t[i+5]:y)-l)/6*e],[f,y],8))}return g(r,0)}(v(t),e,!0);for(let e=0;e<n.length;e++)t[e]=n[e]}),t}(v(this.vertices),t)),this}simplify(t=16){return this.vertices=function(t,e){return x(t,t=>{const r=y(v(t),e),i=function(t){const e=x(t).flat();return n(e)}([t]);t.splice(r.length,t.length-r.length);for(let e=0;e<r.length;e++)t[e]=[(s=r[e])[0]+=0*((o=i)[0]-s[0]),s[1]+=0*(o[1]-s[1])];var s,o;t[t.length-1]=t[0]}),t}(v(this.vertices),t),this}checkIntersection(t,e=1,n=0){try{return!!(t.some(t=>!!A(t.clone().simplify(n),this.clone().simplify(n)).vertices[0])||t.some(t=>!!A(t.clone().simplify(n),this.clone().scale(1*e).simplify(n)).vertices[0])||t.some(t=>!!A(t.clone().simplify(n),this.clone().scale(1/e).simplify(n)).vertices[0]))}catch(t){return!0}}getBounds(){return m(this.vertices)}getArea(){return function(e){const n=x(e).flat();return t(n)}(this.vertices)}clone(){return new J(v(this.vertices))}buildPath(){return O(this.clone())}}function P(t,e){const n=function(t,e){return[[[0,0],[t,0],[t,e],[0,e],[0,0]]]}(t,e);return new J(n)}function $(t,e,n){const r=w(t,e,n);return new J(r)}function I(t,e){const n=w(t,t,e);return new J(n)}function j(t){return new J(t)}function k(t,e){const n=function(t,e=1){return[N(t,e)]}(t,e);return new J(n)}function z(t,e,n,r,i){const s=function(t,e,n,r=1,i=8){return[N(u(t,e,n,i),r)]}(t,e,n,r,i);return new J(s)}export{O as buildPath,I as circle,S as difference,$ as ellipse,A as intersection,k as line,j as polygon,z as quadtratic,P as rect,F as union,q as xor};
//# sourceMappingURL=shapes.modern.js.map
